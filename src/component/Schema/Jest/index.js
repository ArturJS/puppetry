import { RUNNER_PUPPETRY, SELECTOR_CHAIN_DELIMITER, SELECTOR_CSS } from "constant";
import { validateSimpleSelector } from "service/selector";
import { renderSuiteHtml } from "./interactive-mode";
import fs from "fs";
import { join } from "path";

const NETWORK_TIMEOUT = 50000,
      INTERACTIVE_MODE_TIMEOUT = 1800000, // 30min

      normalizeName = ( str ) => {
        const re = /[^a-zA-Z0-9_-]/g;
        return str.replace( re, "--" );
      },

      readInteractAsset = ( outputDirectory, file ) => fs.readFileSync(
        join( outputDirectory, "lib", "interactive-mode", file ), "utf8"
      );

/**
 * Build selector for ShadowDOM
 * e.g. `document.querySelector( ".foo" ).shadowRoot.querySelector( ".bar" )`
 * @param {String} selectorChain
 * @returns {String}
 */
function buildShadowDomQuery( selectorChain ) {
  return "document" + ( selectorChain
    .split( SELECTOR_CHAIN_DELIMITER )
    .map( ( sel ) => `.querySelector("${ sel }")` )
    .join( `.shadowRoot` ) );
}

export const tplQuery = ({ target, selector }) => {
  // in case of chain for shadow DOM
  if ( selector.includes( SELECTOR_CHAIN_DELIMITER ) ) {
    return `const ${ target } = async () => bs.findHandleBySelectorChain( \`${ buildShadowDomQuery( selector ) }\`, `
      + `${ JSON.stringify( target )} );`;
  }
  const func = validateSimpleSelector( selector ) === SELECTOR_CSS ? "findHandleByCss" : "findHandleByXpath";
  return `const ${ target } = async () => bs.${ func }( ${ JSON.stringify( selector )}, `
    + `${ JSON.stringify( target )} );`;
};

function buildEnv( env ) {
  if ( !env || !env.variables ) {
    return "";
  }
  const body = Object.entries( env.variables )
    .map( ([ k, v ]) => `  "${ k }": "${ v }"` )
    .join( ",\n" );
  return `// Environment variables
const ENV = {
${ body }
};`;
}



export const tplSuite = ({
  title, body, targets, suite, runner, projectDirectory, outputDirectory, env, options, interactive
}) => `
/**
 * Generated by https://github.com/dsheiko/puppetry
 * on ${ String( Date() ) }
 * Suite: ${ suite.title }
 */

${ runner !== RUNNER_PUPPETRY ? `var nVer = process.version.match( /^v(\\d+)/ );
if ( !nVer || nVer[ 1 ] < 9 ) {
  console.error( "WARNING: You have an outdated Node.js version " + process.version
    + ". You need at least v.9.x to run this test suite." );
}
` : `` }

const {
        bs, util, fetch, localStorage
      } = require( "../lib/bootstrap" )( ${ JSON.stringify( normalizeName( title ) ) } ),
      devices = require( "puppeteer/DeviceDescriptors" );

${ runner === RUNNER_PUPPETRY ? `
util.setProjectDirectory( ${ JSON.stringify( projectDirectory ) } );
` : `` }

jest.setTimeout( ${ options.interactiveMode ? INTERACTIVE_MODE_TIMEOUT : ( suite.timeout || NETWORK_TIMEOUT ) } );

const consoleLog = [], // assetConsoleMessage
      dialogLog = []; // assertDialog;

${ buildEnv( env ) }

${ targets }

describe( ${ JSON.stringify( title ) }, async () => {
  beforeAll(async () => {
    await bs.setup();

    bs.page.on( "console", ( msg ) => consoleLog.push( msg ) );
    bs.page.on( "dialog", ( dialog ) => dialogLog.push( dialog.message() ) );

    ${ options.requireInterceptTraffic ? `bs.performance.watchTraffic();` : `` }

    ${ options.interactiveMode ? `
    let stepIndex = 0;
    await bs.page.exposeFunction('setPuppetryStepIndex', index => {
      stepIndex = index;
    });

    bs.page.on( "load", async () => {
      await bs.page.addStyleTag({ content: \`${ readInteractAsset( outputDirectory, "toolbox.css" ) }\`});
      await bs.page.addScriptTag({ content: \`
        const data = ${ JSON.stringify( interactive )  };
        let stepIndex = \${ stepIndex };
        const suiteHtml = ${ JSON.stringify( renderSuiteHtml( suite ) ) };
        ${ readInteractAsset( outputDirectory, "toolbox.js" ) }\`});
    });
    ` : `` }
  });

  afterAll(async () => {
    await bs.teardown();
  });

${body}

});
`;

export const tplGroup = ({ title, body }) => `
  describe( ${ JSON.stringify( title ) }, async () => {
${body}
  });
`;

export const tplTest = ({ title, body }) => `
    test( ${ JSON.stringify( title ) }, async () => {
      let result, assert;
${body}
    });
`;